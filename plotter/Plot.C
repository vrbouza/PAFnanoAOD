#include "Plot.h"


Histo* Plot::GetH(TString sample, TString sys, Int_t type) {
  // Returns a Histo for sample and systematic variation
  TString pathToMiniTree = path;
  if     (type == itSignal || sample.Contains("T2tt")) pathToMiniTree = pathSignal;
  else if(type == itData  ) pathToMiniTree = pathData;
  else if(sample.Contains("/")){
    pathToMiniTree = sample(0, sample.Last('/')+1);
    sample = sample(sample.Last('/')+1, sample.Sizeof());
  }
  Looper* ah;
  if(xN != x0) ah = new Looper(pathToMiniTree, treeName, var, cut, chan, nb, x0, xN);
  else         ah = new Looper(pathToMiniTree, treeName, var, cut, chan, nb, vbins);

  ah->SetVerbosity(verbose);
  ah->SetWeight(weight);
  ah->SetOptions(LoopOptions);

  Histo* h = ah->GetHisto(sample, sys); // ARREGLAR ESTE MEMORY LEAK INTERNO

  h->SetDirectory(0);
  h->doStackOverflow = doStackOverflow;
  h->SetStyle();
//  h->Sumw2();
  delete ah;
  return h;
}


void Plot::AddSample(TString p, TString pr, Int_t type, Int_t color, TString sys, TString options) {
  //>>> Multiprocess...
  p.ReplaceAll(" ", "");
  if (pr == "") pr = p;
  if (p.Contains(",") || p.Contains("*")) {
    TString First_p = p(0, p.First(','));
    TString theRest = p(p.First(',') + 1, p.Sizeof());

    if (First_p == "") {
      First_p = theRest;
      theRest = "";
    }

    if (First_p.Contains("*")) {
      void *dirp = gSystem->OpenDirectory(path);
      Char_t *afile;
      while ( (afile = const_cast<Char_t *>(gSystem->GetDirEntry(dirp))) ) {
        TString tmpfile = afile;
        if (tmpfile.Contains(First_p.ReplaceAll("*", ""))) AddSample(tmpfile(0, tmpfile.Index(".root")), pr, type, color, sys, options);
        else continue;
      }
    }
    else AddSample(First_p, pr, type, color, sys, options);

    if (theRest != "") AddSample(theRest, pr, type, color, sys, options);

    return;
  }

  //>>> Propagating options to looper
  SetLoopOptions(options);
  VTagOptions.push_back(options);
  if (sys != "0" && sys != "") AddToSystematicLabels(sys);
  if (type == itBkg || type == itSignal) {
    VTagSamples.push_back(p);    //
    VTagProcesses.push_back(pr);
  }

  //>>> Using MultiLooper??
  if ( (type == itBkg || type == itSignal) && (sys != "" && sys != "0")){
    VTagSamples.push_back(p);
    VTagProcesses.push_back(pr);
    if (type == itSignal){
      nSignalSamples++;
      SetSignalProcess(pr);
    }
    Multiloop(p, pr, type, color, sys);
    return;
  }

  //>>> Getting histo from looper
  Histo* h = GetH(p, sys, type);
//   if (type != itData && !LoopOptions.Contains("noScaleLumi"))  h->Scale(Lumi*1000);
  PrepareHisto(h, p, pr, type, color, sys);
}


void Plot::GetStack(Bool_t doNorm) {
  if (verbose) cout << "[Plot::GetStack] Entering GetStack" << endl;
  if (hStack) delete hStack;
  hStack = new THStack(varname, "");

  UShort_t nBkgs = VBkgs.size();
  if (nBkgs == 0 && verbose) cout << "[Plot::GetStack] WARNING: having no backgrounds was a mistake, you'll pay for that with a SegFault" << endl;

  if (doNorm) {
    Double_t tmpint = 0;
    for (UShort_t i = 0; i < nBkgs; i++) tmpint += VBkgs.at(i)->Integral();
    for (UShort_t i = 0; i < nBkgs; i++) {
      TH1D* tmphist = (TH1D*) VBkgs.at(i);
      tmphist->Scale(1 / tmpint);
      hStack->Add((TH1D*) tmphist);
    }
  }
  else {
    for (UShort_t i = 0; i < nBkgs; i++) hStack->Add((TH1D*) VBkgs.at(i));
  }

  if (doExternalSyst) return;
  if (hAllBkg) delete hAllBkg;
  hAllBkg = (new Histo(*(TH1D*) hStack->GetStack()->Last(), 3))->CloneHisto("AllBkg");
  if (doNorm) hAllBkg->Scale(1 / hAllBkg->Integral());
  hAllBkg->doStackOverflow = doStackOverflow;
  hAllBkg->SetStyle();
  hAllBkg->SetTag("Uncertainty");
  if (doSys && ((UShort_t) VSystLabel.size() > 0)) GroupSystematics();
  if (verbose) cout << Form("[Plot::GetStack] Adding %i systematic to the sum of background...\n", (UShort_t) VSumHistoSystUp.size()) << endl;

  for (UShort_t i = 0; i < (UShort_t) VSumHistoSystUp.size(); i++) {
    hAllBkg->AddToSystematics(VSumHistoSystUp.at(i));
    hAllBkg->AddToSystematics(VSumHistoSystDown.at(i));
  }
  if (doSys && ((UShort_t) VSystLabel.size() > 0)) hAllBkg->SetBinsErrorFromSyst();
  hAllBkg->ReCalcValues();
}


Histo* Plot::GetAllBkgClone(TString newname){
  if(!hStack) GetStack();
  Histo *h = hAllBkg->CloneHisto(newname);
  h->SetDirectory(0);
  return h;
}


Double_t Plot::GetAllBkg(Int_t ibin){
  if(!hStack) GetStack();
  Double_t val = ibin < 0 ? hAllBkg->GetYield() : hAllBkg->GetBinContent(ibin);
  return val;
}


void Plot::SetData(){  // Returns histogram for Data
  if(VhData.size() != 0) return;
  if(!doData){
    GetStack();
    if(hData) delete hData;
    if(gROOT->FindObject("HistoData")) delete gROOT->FindObject("HistoData");
    hData = hAllBkg;
    VhData.push_back(hData);
  }
  if(hData) delete hData;
  if(gROOT->FindObject("HistoData")) delete gROOT->FindObject("HistoData");

  if(x0 != xN) hData = new Histo(TH1D("HistoData", dataTag, nb, x0, xN));
  else         hData = new Histo(TH1D("HistoData", dataTag, nb, vbins));
  if(VData.size() < 1) doData = false;
  TString p = "";

  for(Int_t i = 0; i < (Int_t) VData.size(); i++){
    p = VData.at(i)->GetName();
    if     (chan == "ElMu" && (p == "DoubleMuon" || p == "DoubleEG"))   continue;
    else if((chan == "MuMu" || chan == "Muon") && (p != "DoubleMuon" && p!= "SingleMuon"))  continue;
    else if((chan == "ElEl" || chan == "Elec") && (p != "DoubleEG" && p!= "SingleElec"))    continue;
    else if( (chan == "SF" || chan == "sameF") && (p == "MuonEG"))      continue;
    hData->Add(VData.at(i));
  }
  hData->SetLineColor(kBlack);
  hData->SetMarkerStyle(20);
  hData->SetMarkerSize(1.1);
  hData->doStackOverflow = doStackOverflow;
  hData->SetStyle(); hData->SetType(itData);
  VhData.push_back(hData);
}



void Plot::AddToHistos(Histo* p){ // Add the histogram to the right vector
  if     (p->GetType() == itBkg   ) VBkgs.push_back(p);
  else if(p->GetType() == itSignal) VSignals.push_back(p);
  else if(p->GetType() == itData  ) VData.push_back(p);
  else if(p->GetType() == itOther ) VOther.push_back(p);
  else if(p->GetType() == itSys   ) VSyst.push_back(p);
  else{
    cout << "[Plot::AddToHisto] ERROR: Wrong histo type!!!" << endl;
    return;
  }
  if(verbose) cout << "[Plot::AddToHistos] Added histogram " << p->GetName() << " to " << p->GetTag() << " group (" << p->GetType() << ")" << endl;
}



//================================================================================
// Systematics
//================================================================================
void Plot::AddSystematic(TString var, TString pr){
  if(var == "stat"){
    AddToSystematicLabels("stat");
    AddStatError();
    if(verbose) cout << "[Plot::AddSystematic] Added statistical uncertainties! " << endl;
    return;
  }
  var.ReplaceAll(" ", "");
  if(var.Contains(",")){
    TString OneSyst;
    TString TheRest;
    OneSyst = TString(var(0, var.First(",")));
    TheRest = TString(var(var.First(",")+1, var.Sizeof()));
    AddSystematic(OneSyst, pr);
    AddSystematic(TheRest, pr);
    return;
  }
  if(pr == ""){
    for(Int_t i = 0; i < (Int_t) VTagSamples.size(); i++){
      if(VTagOptions.at(i).Contains("Fake") || VTagOptions.at(i).Contains("fake")) continue;
      AddSample(VTagSamples.at(i), VTagProcesses.at(i), itSys, 1, var+"Up", VTagOptions.at(i));
      AddSample(VTagSamples.at(i), VTagProcesses.at(i), itSys, 1, var+"Down", VTagOptions.at(i));
    }
  }
  else{
    std::vector<TString> vpr = TStringToVector(pr);
    TString p;
    for(Int_t k = 0; k < (Int_t) vpr.size(); k++){
      p = vpr.at(k);
      for(Int_t i = 0; i < (Int_t) VTagSamples.size(); i++){
        if(p != VTagProcesses.at(i)) continue;
        AddSample(VTagSamples.at(i), VTagProcesses.at(i), itSys, 1, var+"Up", VTagOptions.at(i));
        AddSample(VTagSamples.at(i), VTagProcesses.at(i), itSys, 1, var+"Down", VTagOptions.at(i));
      }
    }
  }
  if(verbose) cout << "[Plot::AddSystematic] Systematic histograms added to the list for variation: " << var << endl;
}


void Plot::AddNormSyst( TString process, TString name, Double_t norm)
{
  Histo* hBkgUp = (Histo*) GetHisto(process)->CloneHisto( process + "_" + name + "Up");
  Histo* hBkgDn = (Histo*) GetHisto(process)->CloneHisto( process + "_" + name + "Down");
  hBkgUp->Scale( 1 + norm); hBkgDn->Scale( 1 - norm );
  hBkgUp->SetTag( process + "_" + name + "Up");
  hBkgDn->SetTag( process + "_" + name + "Down");
  hBkgUp->SetProcess( process); hBkgDn->SetProcess( process);
  hBkgUp->SetType( itSys ); hBkgDn->SetType(itSys);
  AddToHistos( hBkgUp ); AddToHistos(hBkgDn);
  AddToSystematicLabels(name);
  return;
}


void Plot::AddLumiSyst( Double_t unc )
// lumi applied to every process :D
{
  vector<TString> alreadyConsidered;
  for (auto& proc : VTagProcesses){
    if (std::find( alreadyConsidered.begin(), alreadyConsidered.end(), proc) == alreadyConsidered.end()){
      alreadyConsidered.push_back(proc);
      AddNormSyst(proc, "lumi", unc);
    }
  }
}


void Plot::AddStatError(TString process){
  TString pr;
  if(process == ""){
    for(Int_t i = 0; i < (Int_t) VTagProcesses.size(); i++){
      pr = VTagProcesses.at(i);
      if(i != 0) if(pr == VTagProcesses.at(i-1)) continue;
      AddStatError(pr);
    }
    return;
  }
  //cout << " --> process = " << process << endl;
  Double_t nom; Double_t stat;
  TString nameUp = process + "_statUp"; TString nameDown = process + "_statDown";
  if(gROOT->FindObject(nameUp)) delete gROOT->FindObject(nameUp);
  if(gROOT->FindObject(nameDown)) delete gROOT->FindObject(nameDown);
  Histo *hUp   = (Histo*)GetHisto(process)->CloneHisto(nameUp);
  Histo* hDown = (Histo*)GetHisto(process)->CloneHisto(nameDown);
  hUp->SetDirectory(0); hDown->SetDirectory(0);
  for(Int_t iBin = 0; iBin <= hUp->GetNbinsX(); iBin++){
    nom = hUp->GetBinContent(iBin); stat = hUp->GetBinError(iBin);
    hUp  ->SetBinContent(iBin, nom+stat);
    hDown->SetBinContent(iBin, nom-stat);
  }
  PrepareHisto(hUp,   process+"_statUp",   process, itSys, 1, "statUp");
  PrepareHisto(hDown, process+"_statDown", process, itSys, 1, "statDown");
}

void Plot::GroupSystematics(){
  TString var = ""; TString pr = "";
  //>>> Here we store the histos
  VSumHistoSystUp.clear(); VSumHistoSystDown.clear();
  Histo* hsumSysUp = NULL; Histo* hsumSysDown = NULL;

  Int_t nBkgs = VBkgs.size();

  //>>> Loop over each systematic
  for(Int_t i = 0; i < (Int_t) VSystLabel.size(); i++){
    var = VSystLabel.at(i);
    hsumSysUp = NULL; hsumSysDown = NULL;
    pr = VBkgs.at(0)->GetProcess();
    hsumSysUp   = GetHisto(pr, var+"Up"  )->CloneHisto(pr + "_" + var + "Up");
    hsumSysDown = GetHisto(pr, var+"Down")->CloneHisto(pr + "_" + var + "Down");
    for(Int_t i = 1; i < nBkgs; i++){
      pr = VBkgs.at(i)->GetProcess();
      hsumSysUp  ->Add(GetHisto(pr, var+"Up"  ));
      hsumSysDown->Add(GetHisto(pr, var+"Down"));
    }
    hsumSysUp  ->SetName(var  + "_SystSumUp"   );
    hsumSysDown->SetName(var + "_SystSumDownn");
    AddSumHistoSystematicUp(hsumSysUp);
    AddSumHistoSystematicDown(hsumSysDown);
  }
}


void Plot::Multiloop(TString p, TString pr, Int_t type, Int_t color, TString sys) {
  TString pathToMiniTree = path;
  TString sample = p;
  if     (type == itSignal || sample.Contains("T2tt")) pathToMiniTree = pathSignal;
  else if(type == itData  ) pathToMiniTree = pathData;
  else if(sample.Contains("/")){
    pathToMiniTree = sample(0, sample.Last('/')+1);
    sample = sample(sample.Last('/')+1, sample.Sizeof());
  }

  Multilooper* ah;
  if(xN != x0) ah = new Multilooper(pathToMiniTree, treeName, var, cut, chan, nb, x0, xN);
  else         ah = new Multilooper(pathToMiniTree, treeName, var, cut, chan, nb, vbins);

  ah->SetVerbosity(verbose);
  ah->SetWeight(weight);
  ah->SetOptions(LoopOptions);
  ah->SetSampleName(sample);
  ah->SetSystematics(sys);
  ah->Fill();

  vector<Histo*> vH = ah->GetAllHistos();
  if(type != itData && !LoopOptions.Contains("noScaleLumi"))
  for(Int_t i = 0; i < (Int_t) vH.size(); i++) vH.at(i)->Scale(Lumi*1000);
  PrepareHisto(vH, sample, pr, type, color);
}


void Plot::PrepareHisto(vector<Histo*> vH, TString sampleName, TString pr, Int_t type, Int_t color, TString sys) {
  Int_t n = vH.size(); Int_t i = 0;
  PrepareHisto(vH.at(0), sampleName, pr, type, color, sys);
  for(i = 1; i < n; i++) PrepareHisto(vH.at(i), sampleName, pr, itSys, color, sys);
}


void Plot::PrepareHisto(Histo* h, TString sampleName, TString pr, Int_t type, Int_t color, TString sys) {
  TString s = (sys == "" || sys == "0") ? h->GetSysTag() : sys;
  TString p = pr;
  TString name = sampleName;
  if(s != "0" && s != "")  p    = pr   + "_" + s;
  if(s != "0" && s != "")  name = name + "_" + s;
  h->SetSysTag(s);
  h->SetProcess(pr); h->SetTag(p); h->SetName(name);
  h->SetType(type); h->SetColor(color);
  h->doStackOverflow = doStackOverflow;
  h->SetStyle();
  h->SetDirectory(0);
  Group(h);
}


void Plot::AddHistoFromFile(TString filename, TString name, Int_t type, Int_t color, TString sys, TString pathInRootfile){
  if(!filename.EndsWith(".root")) filename += ".root";
  //cout << "[Plot::AddHistoFromFile] Searching for histogram \n   --> " << pathInRootfile + name << "\n in file: \n   --> " << filename << endl;
  TFile* f = TFile::Open(filename);
  TH1D* h = (TH1D*) f->Get(pathInRootfile + name);
  h->SetName(h->GetName() + TString("_2"));
  Histo* histo;
  if(x0 == xN) histo = new Histo(TH1D(name, name, nb, vbins));
  else         histo = new Histo(TH1D(name, name, nb, x0, xN));
  histo->SetDirectory(0);
  for(Int_t i = 1; i <= nb; i++){
    histo->SetBinContent(i, h->GetBinContent(i));
    histo->SetBinError(i, h->GetBinError(i));
  }
  PrepareHisto(histo, name, name, type, color, sys);
  delete f;
}

void Plot::AddHistoFromFileTGraph(TString filename, TString name, Int_t type, Int_t color, TString sys, TString pathInRootfile){
  if(!filename.EndsWith(".root")) filename += ".root";
  Histo* histo;
  if(x0 == xN) histo = new Histo(TH1D(name, name, nb, vbins));
  else         histo = new Histo(TH1D(name, name, nb, x0, xN));
  TFile* f = TFile::Open(filename);
  TGraph* g = (TGraph*) f->Get(pathInRootfile + name);
  histo->SetDirectory(0);
  const Int_t n = g->GetN();
  Double_t x; Double_t y;
  for(Int_t i = 0; i < n; i++){
    x = *g->GetX()+i;
    y = g->Eval(x);
    //cout << Form("[x,y] = [%1.2f, %1.2f]\n", x, y);
    histo->SetBinContent(i+1, y);
  }
  PrepareHisto(histo, name, name, type, color, sys);
  delete f;
}


void Plot::Group(Histo* h) {
  TString t = h->GetTag();
  TString tag; Int_t type = h->GetType();
  Int_t n; Int_t i;
  if (type == itBkg) {
    n = VBkgs.size();
    for (i = 0; i < n; i++) {
      tag = VBkgs.at(i)->GetTag();
      if (t == tag) {
        cout << "antes, el original: " << VBkgs.at(i)->GetYield() << " " << VBkgs.at(i)->Integral() << endl;
        cout << "antes, el nuevu: " << h->GetYield() << " " << h->Integral() << endl;
        VBkgs.at(i)->Add((TH1D*) h);
        VBkgs.at(i)->ReCalcValues();
        cout << "despues, el original: " << VBkgs.at(i)->GetYield() << " " << VBkgs.at(i)->Integral() << endl;
        cout << "despues, el nuevu: " << h->GetYield() << " " << h->Integral() << endl;
        if (verbose) cout << "[Plot::Group] Added histogram " << h->GetName() << " to " << h->GetTag() << " group (" << type << ")" << endl;
        return;
      }
    }
  }
  else if(type == itSignal){
    n = VSignals.size();
    for(i = 0; i < n; i++){
      tag = VSignals.at(i)->GetTag();
      if(t == tag){
        VSignals.at(i)->Add((TH1D*) h);
        VSignals.at(i)->ReCalcValues();
        if (verbose) cout << "[Plot::Group] Added histogram " << h->GetName() << " to " << h->GetTag() << " group (" << type << ")" << endl;
        return;
      }
    }
  }
  else if(type == itSys){
    n = VSyst.size();
    for(i = 0; i < n; i++){
      tag = VSyst.at(i)->GetTag();
      if(t == tag){
        VSyst.at(i)->Add((TH1D*) h);
        VSyst.at(i)->ReCalcValues();
        if (verbose) cout << "[Plot::Group] Added histogram " << h->GetName() << " to " << h->GetTag() << " group (" << type << ")" << endl;
        return;
      }
    }
    h->SetName(t);
  }
  else if(type == itData){
    VTagDataSamples.push_back(h->GetName());
    h->SetLineColor(kBlack);
    h->SetMarkerStyle(20);
    h->SetMarkerSize(1.1);
  }
  else{ // type == itOther

  }
  AddToHistos(h);
}



//================================================================================
// Drawing
//================================================================================
Double_t Plot::GetData(Int_t ibin) {
  if (!hData) SetData();
  Double_t y = hData->GetYield();
  if (ibin >= 0) y = hData->GetBinContent(ibin);
  return y;
}


Histo* Plot::GetHData() {
  if(!hData) SetData();
  return VData.at(0);
}


Histo* Plot::GetHisto(TString pr, TString systag) {
  if(pr == "Data") return GetHData();
  Double_t val = 0; Double_t sys = 0; TString ps;
  Int_t nSyst = VSyst.size();
  Int_t nBkg = VBkgs.size();
  Int_t nSig = VSignals.size();
  Int_t nOther = VOther.size();
  if(systag == "0" || systag == ""){
    for(Int_t i = 0; i < nBkg;   i++) if(pr == VBkgs.at(i)   ->GetProcess()) return  VBkgs.at(i);
    for(Int_t i = 0; i < nSig;   i++) if(pr == VSignals.at(i)->GetProcess()) return  VSignals.at(i);
    for(Int_t i = 0; i < nOther; i++) if(pr == VOther.at(i)  ->GetProcess()) return  VOther.at(i);
    return 0;
  }
  else{
    for(Int_t k = 0; k < nSyst; k++){
      ps = VSyst.at(k)->GetTag();
      if(!ps.BeginsWith(pr))   continue;
      if(!ps.EndsWith(systag)) continue;
      return VSyst.at(k);
    }
    for(Int_t k = 0; k < nSig; k++){
      ps = VSignals.at(k)->GetTag();
      if(!ps.BeginsWith(pr))   continue;
      if(!ps.EndsWith(systag)) continue;
      return VSignals.at(k);
    }
  }
  //cout << "[Plot::GetHisto] WARNING: No systematic " << systag << " for process " << pr << "........... Returning nominal histo..." << endl;
  return GetHisto(pr, "0");
}


Int_t Plot::GetProcessType(TString pr, TString systag){
  if(systag != "0" && systag != "") return itSys;
  Int_t nBkg = VBkgs.size();
  Int_t nSig = VSignals.size();
  Int_t nOth = VOther.size();
  for(Int_t i = 0; i < nBkg; i++) if(pr == VBkgs.at(i)   ->GetProcess()) return  itBkg;
  for(Int_t i = 0; i < nSig; i++) if(pr == VSignals.at(i)->GetProcess()) return  itSignal;
  for(Int_t i = 0; i < nOth; i++) if(pr == VOther.at(i)->GetProcess())   return  itOther;
  if(verbose) cout << "[Plot::GetProcessType]: Not found process " << pr << endl;
  return -1;
}


Int_t Plot::GetProcessIndex(TString pr, TString systag){
  Int_t type = GetProcessType(pr, systag);
  Int_t nBkg = VBkgs.size();
  Int_t nSig = VSignals.size();
  Int_t nOth = VOther.size();
  Int_t nSyst = VSyst.size();
  if     (type == itBkg){    for(Int_t i = 0; i < nBkg; i++) if(pr == VBkgs.at(i)   ->GetProcess()) return i;}
  else if(type == itSignal){ for(Int_t i = 0; i < nSig; i++) if(pr == VSignals.at(i)->GetProcess()) return i;}
  else if(type == itOther){  for(Int_t i = 0; i < nOth; i++) if(pr == VOther.at(i)->GetProcess())   return i;}
  else if(type == itSys){
    TString ps = "";
    for(Int_t k = 0; k < (Int_t) VSyst.size(); k++){
      ps = VSyst.at(k)->GetTag();
      if(ps.BeginsWith(pr) && ps.EndsWith(systag)) return k;
    }
  }
  return -1;
}


void Plot::RemoveProcess(TString pr, TString systag){
  Int_t type = GetProcessType(pr, systag);
  Int_t pos  = GetProcessIndex(pr, systag);
  if     (type == itBkg)    VBkgs.erase(   VBkgs.begin() + pos);
  else if(type == itSignal) VSignals.erase(VBkgs.begin() + pos);
  else if(type == itSys)    VSyst.erase(   VBkgs.begin() + pos);
  else{
    if(verbose) cout << "[Plot::RemoveProcess]: Not found process " << pr << ", with syst " << systag << endl;
    return;
  }
  if(systag == "" || systag == "0"){
    Int_t nS = VSyst.size(); Int_t iS;
    TString ps;
    for(iS = 0; iS < nS; iS++){
      ps = VSyst.at(iS)->GetProcess();
      if(pr == ps){
        VSyst.erase(VSyst.begin() + iS);
        iS--; nS--;
      }
    }
  }
}


Bool_t Plot::Exists(TString pr, TString systag){
  if(GetProcessIndex(pr, systag) == -1) return false;
  else return true;
}


Bool_t Plot::RenameProcess(TString pr, TString newname, TString systag){
  if(Exists(newname, systag)) return false;
  TString t = newname;
  Histo *h = GetHisto(pr, systag);
  h->SetProcess(newname);
  if(systag != "" && systag != "0") t += "_" + systag;
  h->SetTag(t);

  // Propagate to all systematics
  Int_t nSyst = VSystLabel.size();
  TString s;
  if(systag == "" || systag == "0"){
    for(Int_t iS = 0; iS < nSyst; iS++){
      s = VSystLabel.at(iS);
      if(s == pr){ // Changing the name to the normalization systematic
        Histo* gup = GetHisto(pr, s+"Up");
        gup->SetProcess(newname);
        gup->SetTag(newname + "_" + newname + "Up");
        Histo* gdo = GetHisto(pr, s+"Down");
        gdo->SetProcess(newname);
        gdo->SetTag(newname + "_" + newname + "Down");
        continue;
      }
      if(Exists(pr, s))          RenameProcess(pr, newname, s       );
      if(Exists(pr, s + "Up"  )) RenameProcess(pr, newname, s+"Up"  );
      if(Exists(pr, s + "Down")) RenameProcess(pr, newname, s+"Down");
    }
    return true;
  }
  return true;
}


void Plot::GroupProcesses(TString pr, TString newProcess){
  if(pr.Contains(",")){
    vector<TString> vpr = TStringToVector(pr);
    for(Int_t i = 0; i < (Int_t) vpr.size(); i++) GroupProcesses(vpr.at(i), newProcess);
    return;
  }
  if(!Exists(pr)){
    cout << "[Plot::GroupProcesses] ERROR: process \"" << pr << "\" does not exist!" << endl;
    return;
  }
  if(!Exists(newProcess)){
    //cout << "No existe el proceso nuevo: " << newProcess << endl;
    RenameProcess(pr, newProcess);
    return;
  }
  //cout << "Existe el proceso nuevo " << newProcess << endl;
  if(Exists(pr,pr+"Up")   && Exists(newProcess,newProcess+"Up")  ) AddUncToHisto(newProcess, newProcess+"Up", pr, pr+"Up");
  if(Exists(pr,pr+"Down") && Exists(newProcess,newProcess+"Down")) AddUncToHisto(newProcess, newProcess+"Down", pr, pr+"Down");
  GetHisto(newProcess)->Add(GetHisto(pr));
  Int_t nSyst = VSyst.size(); TString s;
  for(Int_t iS = 0; iS < (Int_t) VSystLabel.size(); iS++){
    if(s == pr) continue;
    s = VSystLabel.at(iS);
    if(Exists(pr, s) && Exists(newProcess,s))                 GetHisto(newProcess, s)->Add(GetHisto(pr,s));
    if(Exists(pr, s + "Up"  ) && Exists(newProcess,s+"Up"))   GetHisto(newProcess, s+"Up")->Add(GetHisto(pr,s+"Up"));
    if(Exists(pr, s + "Down") && Exists(newProcess,s+"Down")) GetHisto(newProcess, s+"Down")->Add(GetHisto(pr,s+"Down"));
    GetHisto(newProcess, s+"Up")->ReCalcValues();
    GetHisto(newProcess, s+"Down")->ReCalcValues();
  }
  GetHisto(newProcess, s)->ReCalcValues();
  // TODO: Add proper norm uncertainties!!
  RemoveProcess(pr);
}


Histo* Plot::GetHistoError(TString pr, TString syst){
  Histo *h = GetHisto(pr, syst)->CloneHisto("RelUnc_" + pr + "_" + syst);
  Histo* n = GetHisto(pr);

  Int_t nbins = h->GetNbinsX(); Double_t err;
  Double_t nom; Double_t sys = 0;
  for(Int_t i = 0; i <= nbins; i++){
    nom = n->GetBinContent(i);
    sys = h->GetBinContent(i);
    //cout << Form("GetHistoError, process %s, syst %s: [%i] nom = %1.2f, var = %1.2f\n", pr.Data(), syst.Data(), i, nom, sys);
    err = fabs(nom-sys);
    h->SetBinContent(i, err);
  }
  h->SetDirectory(0);
  return h;
}


void Plot::AddUncToHisto(TString pr, TString sys, TString pr_new, TString sys_new){
  Histo* hnom = GetHisto(pr);
  Histo* hnew = GetHisto(pr_new);
  Histo* hsys = GetHisto(pr, sys);
  Histo* herr_orig = GetHistoError(pr, sys);
  Histo* herr_new  = GetHistoError(pr_new, sys_new);

  Int_t nbins = hnom->GetNbinsX(); Double_t n = 0; Double_t s = 0; Double_t v = 0; Double_t a = 0; Double_t err_orig; Double_t err_new;
  for(Int_t i = 0; i <= nbins; i++){
    n = hnom->GetBinContent(i);
    a = hnew->GetBinContent(i);
    s = hsys->GetBinContent(i);
    err_orig = herr_orig->GetBinContent(i);
    err_new  = herr_new->GetBinContent(i);
    v = TMath::Sqrt(err_orig*err_orig + err_new*err_new);
    //cout << Form("AddUncToHisto: [%i] nom = %1.2f, syst = %1.2f || new = %1.2f, systnew = %1.2f\n", i, n, err_orig, a, err_new);
    if(s > n) hsys->SetBinContent(i, n + a + v); else hsys->SetBinContent(i, n + a - v);
  }
}


Histo* Plot::GetSymmetricHisto(TString pr, TString systag){
  Histo* nom = GetHisto(pr, "0");
  Histo* var = GetHisto(pr, systag);
  Histo* sym = (Histo*) var->CloneHisto("newHisto");
  Int_t nbins = nom->GetNbinsX();
  Double_t bindiff = 0; Double_t cont;
  for(Int_t i = 0; i <= nbins+1; i++){
    cont    = nom->GetBinContent(i);
    bindiff = var->GetBinContent(i)-nom->GetBinContent(i);
    sym->SetBinContent(i, cont - bindiff);
  }
  sym->SetDirectory(0);
  sym->SetType(var->GetType());
  sym->SetColor(var->GetColor());
  TString newtag = systag;
  if(systag.Contains("Up")) newtag.ReplaceAll("Up", "Down");
  else newtag.ReplaceAll("Down", "Up");
  sym->SetTag(pr + "_" + newtag); sym->SetSysTag(newtag);
  sym->SetProcess(pr);
  sym->SetName(pr + "_" + newtag);
  return sym;
}


void Plot::AddSymmetricHisto(TString pr, TString systag){
  Histo* h = GetSymmetricHisto(pr, systag);
  AddToHistos(h);
}


Double_t Plot::GetYield(TString pr, TString systag, Int_t ibin){
  if(pr == "Data" || pr == "data") return GetData(ibin);
  if(pr == "AllBkg" || pr == "Background") return GetAllBkg(ibin);
  Double_t val = 0; Double_t sys = 0; TString ps;
  Int_t nSyst = VSyst.size();
  Int_t nBkg = VBkgs.size();
  Int_t nSig = VSignals.size();
  if(systag == "0" || systag == ""){
    for(Int_t i = 0; i < nBkg; i++){
      if(pr == VBkgs.at(i)->GetProcess()){
        val = VBkgs.at(i)->GetYield();
        if(ibin >= 0) val = VBkgs.at(i)->GetBinContent(ibin);
        return val;
      }
    }
    for(Int_t i = 0; i < nSig; i++){
      if(pr == VSignals.at(i)->GetProcess()) {
        val = VSignals.at(i)->GetYield();
        if(ibin >= 0) val = VSignals.at(i)->GetBinContent(ibin);
        return val;
      }
    }
    return 0;
  }
  else{
    Double_t nom = GetYield(pr, "0", ibin);
    Double_t var = 0; Double_t diff = 0; Double_t tempvar = 0;
    for(Int_t k = 0; k < nSyst; k++){ // Systematics in k
      ps = VSyst.at(k)->GetTag();
      if(!ps.BeginsWith(pr))   continue;
      if(!ps.Contains(systag)) continue;
      tempvar = ibin < 0 ? VSyst.at(k)->GetYield() : VSyst.at(k)->GetBinContent(ibin);
      if( TMath::Abs(tempvar - nom) > diff){
        var = tempvar;
        diff = TMath::Abs(tempvar - nom);
      }
    }
    if(var != 0) return var;
  }
  //cout << "[Plot::GetYield] WARNING: No systematic " << systag << " for process " << pr << "!!! ...... Returning nominal value... " << endl;
  return GetYield(pr, "", ibin);
}


TLegend* Plot::SetLegend(){ // To be executed before using the legend
  TLegend* leg = new TLegend(fLegX1, fLegY1, fLegX2, fLegY2);
  leg->SetTextSize(LegendTextSize);
  leg->SetBorderSize(0);
  leg->SetFillColor(10);
  leg->SetNColumns(fnLegCol);
  Double_t MinYield = 0;
  Int_t nVBkgs = VBkgs.size();
  if(nVBkgs > 0 && hAllBkg) MinYield = hAllBkg->GetYield()/5000;

  if(doSignal){
    Int_t nSignals = VSignals.size();
    if(SignalStyle == "CrossSection" || SignalStyle == "xsec" || SignalStyle == "Bkg" || SignalStyle == "Fill"){
      for(Int_t i = 0; i < nSignals; i++){
      //  if(VSignals.at(i)->GetProcess() == SignalProcess){
          VSignals.at(i)->SetLineWidth(2);
          VSignals.at(i)->SetFillColor(VSignals.at(i)->GetColor());
          VSignals.at(i)->AddToLegend(leg, doYieldsInLeg);
      //  }
      }
    }
    else if((SignalStyle == "SM" || SignalStyle == "H")){
      for(Int_t i = 0; i < nSignals; i++){
      // if(VSignals.at(i)->GetProcess() == SignalProcess){
          VSignals.at(i)->SetLineWidth(2);
          VSignals.at(i)->SetFillColor(0);
          VSignals.at(i)->AddToLegend(leg, doYieldsInLeg);
      // }
      }
    }
  }

  if(doData && hData && VData.size() > 0){
    hData->SetTag(dataTag);
    hData->SetProcess(dataTag);
    hData->AddToLegend(leg,doYieldsInLeg);
  }

  for(Int_t i = nVBkgs-1; i >= 0; i--){
    if(VBkgs.at(i)->GetYield() < MinYield) continue;
    else VBkgs.at(i)->AddToLegend(leg,doYieldsInLeg);
  }

  if(doSys && doUncInLegend && ((Int_t) VSystLabel.size() > 0)) hAllBkg->AddToLegend(leg,doYieldsInLeg); // add legend for uncertainty
//   if(doSys && doUncInLegend && ((Int_t) VSystLabel.size() > 0)) leg->AddEntry(hAllBkg, "Uncertainty", "f"); // add legend for uncertainty

  if(doSignal && (SignalStyle == "scan" || SignalStyle == "BSM" || SignalStyle == "") )
    for(Int_t i = VSignals.size()-1; i >= 0; i--) VSignals[i]->AddToLegend(leg, doYieldsInLeg);

  return leg;
}

void Plot::SetLegendPosition(TString pos) {
  if (pos=="UR")
    SetLegendPosition(0.70, 0.65, 0.93, 0.93);
  else if (pos == "UL")
    SetLegendPosition(0.15, 0.65, 0.38, 0.85);
  else if (pos == "DL")
    SetLegendPosition(0.15, 0.25, 0.38, 0.45);
  else {
    cout << "[Plot::SetLegendPosition] Sorry, position " << pos << " is not yet implemented. Fucking do it yourself" << endl;
  }
}


TCanvas* Plot::SetCanvas(){ // Returns the canvas
//   TCanvas* c= new TCanvas("c", "c", 10, 10, 800, 600);
  TCanvas* c= new TCanvas("c", "c", 10, 10, widthcanvas, heightcanvas);
  c->Divide(1,2);

  vector<Float_t> vPadRatioMargins = TStringToFloat(kPadRatioMargins);
  vector<Float_t> vPadRatioLimits  = TStringToFloat(kPadRatioLimits);

  plot = (TPad*)c->GetPad(1);
  SetPad(plot, kPadPlotLimits, kPadPlotMargins, kPadPlotSetGrid);

  pratio = (TPad*)c->GetPad(2);
  SetPad(pratio, kPadRatioLimits, kPadRatioMargins, kPadRatioSetGrid);

  if(textForLumi.Contains("%")) textForLumi = Form(textForLumi, Lumi);
  texlumi = new TLatex(-20.,50., textForLumi); // Form("%2.1f fb^{-1}, #sqrt{s} = 13 TeV", Lumi)
  texlumi->SetNDC();
  texlumi->SetTextAlign(12);
  texlumi->SetX(texlumiX); // 0.73
  texlumi->SetY(texlumiY); // 0.97
  texlumi->SetTextFont(42);
  texlumi->SetTextSize(texlumiSize); // 0.05
  texlumi->SetTextSizePixels(22);

  texcms = new TLatex(0.,0., CMSlabel);
  texcms->SetNDC();
  texcms->SetTextAlign(12);
  texcms->SetX(texCMSX); // 15
  texcms->SetY(texCMSY); // 89
  //texcms->SetTextFont(42);
  texcms->SetTextSize(texCMSsize); // 0.06
  texcms->SetTextSizePixels(22); // 22

  texPrelim  = new TLatex(0.,0., CMSmodeLabel);
  texPrelim->SetNDC();
  texPrelim->SetTextAlign(12);
  texPrelim->SetX(texPrelimX); // 15
  texPrelim->SetY(texPrelimY); // 83
  texPrelim->SetTextFont(52);
  texPrelim->SetTextSize(texPrelimSize); // 0.052
  texPrelim->SetTextSizePixels(22); // 22

  return c;
}


void Plot::DrawComp(TString tag, Bool_t doNorm, TString options){
  doUncInLegend = false;
  TString drawstyle = "pe";
  if(options.Contains("hist")) drawstyle = "hist";
  if(options.Contains("style=l")) drawstyle = "l";
  TCanvas* c = SetCanvas();  plot->cd();
  Int_t nsamples = VSignals.size();
  Double_t themax = 0;
  Double_t yield = 0;


  //>>> Set Signal
  Histo* signal;
  //if(nsamples == 0) return;
  signal = VSignals.at(0);
  yield = VSignals.at(0)->Integral();
  if(doNorm) signal->Scale(1/yield);
  TString sD = signal->GetDrawStyle();
  if(sD == "") sD = drawstyle;
  signal->SetDrawStyle(sD);
  signal->SetTitle("");
  signal->SetLineWidth(3);
  signal->SetMarkerStyle(24); signal->SetMarkerSize(1.8);
  signal->GetXaxis()->SetLabelSize(0.0);
  signal->GetXaxis()->SetTitle("");
  signal->Draw(signal->GetDrawStyle());
  SetAxis(signal->GetYaxis(), ytitle, ytitleSize, ytitleOffset, ytitleDivisions, ytitleLabelSize);
  signal->GetYaxis()->CenterTitle();

  //>>> Set maximum and drawing all samples
  Double_t max = VSignals.at(0)->GetMaximum();
  for (Int_t  i = 1; i < nsamples; i++) {
    yield = VSignals.at(i)->Integral();
    if (doNorm) VSignals.at(i)->Scale(1/yield);
    max = VSignals.at(i)->GetMaximum();
    if (max > themax) themax = max;
    VSignals.at(i)->Draw(drawstyle + "same");
  }
  signal->SetMaximum(themax*ScaleMax);
  if (!doSetLogy) {
    PlotMinimum = PlotMinimum == -999? 0 : PlotMinimum;
    plot->SetLogy(0);
  }
  signal->SetMinimum(PlotMinimum);
  if (doSetLogy) {
    if (PlotMinimum == 0 || PlotMinimum == -999)  PlotMinimum = 1e-2;
    PlotMaximum = PlotMaximum == -999? themax*50 : PlotMaximum;
    signal->SetMaximum(PlotMaximum);
    signal->SetMinimum(PlotMinimum);
    plot->SetLogy();
  }

  //>>> Setting legend and labels...
  TLegend* leg = SetLegend();
  texcms->Draw("same");     // CMS
  texlumi->Draw("same");    // In that case, you probably need only the sqrt(s)
  texPrelim->Draw("same");  // Preliminary
  if (chlabel != "") {
    SetTexChan();
    texchan->Draw("same");
  }
  if(doLegend) leg->Draw("same");

  //>>> Chi square
  if(gof!=""){
      cout << "WARNING: at the moment, only the GoF between the first and the second plot is supported. If you plot more than two plots, the remaining ones will be ignored. Further functionality will be added later." << endl;
      double pvalue(-999.);
      TString theComp("");
      if(nsamples>1){
          if(gof=="chi2"){
              pvalue=VSignals.at(0)->Chi2Test(VSignals.at(1), "WW CHI2/NDF");
              theComp="#frac{#chi^2}{NDOF}";
              cout << "WARNING: this is good for comparisons between Weighted-Weighted histograms, i.e. for comparisons between MonteCarlos. Todo: add switch for comparing data w/ MC or data w/ data." << endl;
            }
          else if(gof=="ks"){
              pvalue=VSignals.at(0)->KolmogorovTest(VSignals.at(1), "X");
              theComp="p-value (KS)";
              cout << "WARNING: this does not include comparison of normalization. Todo: add switch for that. Also, this runs pseudoexperiments, and will fail in case of negative bin contents. In case of negative weights, please rebin them to elimitate any negative bin content." << endl;
            }
          else if(gof=="ad"){
              pvalue=VSignals.at(0)->AndersonDarlingTest(VSignals.at(1));
              theComp="p-value (AD)";
              cout << "WARNING: the Anderson Darling test does not work for bins with negative content, at least in the ROOT implementation" << endl;
            }
          else  cout << "ERROR: this GoF test does not exist or is not currently implemented. What a cruel world." << endl;
        }
      else cout << "ERROR: only one sample is selected. How can I compare it with another one?" << endl;

      TText *t = new TText(.7,.7,Form("%s: %f", theComp.Data(), pvalue));
      t->SetTextAlign(22);
      t->SetTextColor(kRed+2);
      t->SetTextFont(43);
      t->SetTextSize(40);
      t->SetTextAngle(45);
      t->Draw("same");
  }

  //>>> Setting ratio histogram
  pratio->cd();
  vector<TH1D*> ratios;
  TH1D* htemp = NULL;
  hratio = (TH1D*)VSignals.at(0)->Clone("hratio_sig");
  SetHRatio();
  if(options.Contains("ratiocolor")){
    for(Int_t  i = 1; i < nsamples; i++){
      if(VSignals.at(i)->GetColor() == VSignals.at(i-1)->GetColor()){
        hratio = (TH1D*)VSignals.at(i-1)->Clone("hratio");
        htemp  = (TH1D*)VSignals.at(i  )->Clone("htemp");
        htemp->Divide(hratio);
        SetHRatio(htemp);
        htemp->SetLineColor(VSignals.at(i)->GetColor());
        htemp->SetLineStyle(VSignals.at(i)->GetLineStyle());
        htemp->SetMarkerColor(VSignals.at(i)->GetColor());
        htemp->SetMarkerStyle(VSignals.at(i)->GetMarkerStyle());
        //htemp->SetDrawStyle(VSignals.at(i)->GetDrawStyle());

        i++;
      }
    }
    for(Int_t k = 0; k < (Int_t) ratios.size(); k++){
      //sD = ratios.at(k)->GetDrawStyle();
      sD = drawstyle;
      ratios.at(k)->Draw(sD + "same");
    }
  }
  else{
    for(Int_t  i = 1; i < nsamples; i++){
      //htemp = (TH1D*)hratio->Clone("htemp");
      //htemp->Divide(VSignals.at(i));
      htemp = (TH1D*)VSignals.at(i)->Clone("htemp");
      htemp->Divide(hratio);
      SetHRatio(htemp);

      htemp->SetLineColor(VSignals.at(i)->GetColor());
      htemp->SetLineStyle(VSignals.at(i)->GetLineStyle());
      htemp->SetMarkerColor(VSignals.at(i)->GetColor());
      htemp->SetMarkerStyle(VSignals.at(i)->GetMarkerStyle());
      ratios.push_back(htemp);
      //sD = ratios.at(i-1)->GetDrawStyle();
      sD = drawstyle;
      ratios.at(i-1)->Draw(sD + "same");
    }
  }

  //>>> Saving the plot...
  TString dir = plotFolder;
  TString plotname = (outputName == "")? varname : outputName;
  if(outputName != "" && varname != "")  plotname += "_" + varname;
  if(plotname != "" && tag != "")      plotname += "_" + tag;
  if(plotname == "" && tag != "")      plotname = tag;

  gSystem->mkdir(dir, kTRUE);
  plotname.ReplaceAll(" ","");
  plotname.ReplaceAll("/","_");
  c->Print( dir + plotname + ".png", "png");
  c->Print( dir + plotname + ".pdf", "pdf");
  c->Print( dir + plotname + ".eps", "eps");
  if(htemp) delete htemp;
  ratios.clear();
}


void Plot::DrawStack(TString tag, Bool_t doNorm) {
  if (verbose) cout << "[Plot::DrawStack] Entering DrawStack." << endl;
  std::vector<Histo*> VStackedSignals;
  if (verbose) cout << "[Plot::DrawStack] Setting Canvas..." << endl;
  TCanvas* c = SetCanvas(); plot->cd();
  SetData();
  GetStack(doNorm);
  if (dataStyle.Contains("l")  || dataStyle.Contains("L") || dataStyle.Contains("hist")){ hData->SetLineWidth(2); hData->SetLineColor(1);}
  if (verbose) cout << "[Plot::DrawStack] Integral of hAllBkg: " << hAllBkg->Integral() << endl;

  //--------- Plotting options for the signal
  if (verbose) cout << "[Plot::DrawStack] Adjusting signal settings." << endl;
  Int_t nSignals = 0;
  VSignalsStack.clear();
  Histo* hSignal = nullptr;
  if (doSignal) {
    nSignals = VSignals.size();
    if (verbose) cout << "[Plot::DrawStack] Drawing " << nSignals << " signals..." << endl;
    for (Int_t i = 0; i < nSignals; i++) if(VSignals.at(i)->GetProcess() == SignalProcess) hSignal = VSignals.at(i);
    if (verbose) cout << "[Plot::DrawStack] Setting signal..." << endl; if((Int_t) VSignals.size() >= 0) hSignal = VSignals.at(0);
    hSignal->ReCalcValues();
    if (verbose) cout << "[Plot::DrawStack] Signal process: " << SignalProcess << endl;
    if ((SignalStyle == "SM" || SignalStyle == "H")) { // Only supports one signal
      for(Int_t i = 0; i < nSignals; i++){
        //hStack->Add(hSignal);
        hSignal->SetFillColor(0);
        hSignal->SetLineColor(hSignal->GetColor());
        hSignal->SetLineWidth(2);
        hSignal->Add( (TH1D*)  ((TH1D*) hStack->GetStack()->Last()) -> Clone("StackForSignal_"+hSignal->GetProcess()) );
        VSignalsStack.push_back(hSignal);
      }
    }
    else if (SignalStyle == "CrossSection" || SignalStyle == "xsec" || SignalStyle == "Bkg" || SignalStyle == "Fill"){
      hSignal->SetLineWidth(3);
      hSignal->SetLineColor(hSignal->GetColor());
      hSignal->SetFillColor(hSignal->GetColor());
      //hStack->Add(hSignal);
    }
    if (doNorm) hSignal->Scale(1 / hSignal->Integral());
  }
/*  TH1D* hSigDraw;
  if(doSignal){
    hSigDraw = (TH1D*) hSignal->Clone("hSigDraw");
    hSigDraw->Add((TH1D*) hAllBkg->Clone("hAllBkg_clone"));
    hSigDraw->Draw("hist");
  }*/

  hStack->Draw("hist");
  if (verbose) cout << "[Plot::DrawStack] Integral of hAllBkg: " << hAllBkg->Integral() << ", yield: " << hAllBkg->GetYield() << endl;
  if (verbose) cout << "[Plot::DrawStack] Number of signals from the stack: " << VSignalsStack.size() << endl;
  //for(Int_t i = 0; i < (Int_t) VSignalsStack.size(); i++) VSignalsStack.at(i)->Draw("hist,same");
/*  if((SignalStyle == "SM" || SignalStyle == "H")){
    Histo* AddMe = hAllBkg->CloneHisto("AddMeToLegend");
    AddMe->SetDirectory(0);
    for(Int_t i = 0; i < (Int_t) VSignals.size(); i++){
      VSignals.at(i)->Add(AddMe);
      if(doSignal) VSignals.at(i)->Draw("hist,same");
      //if(doSignalUnc) VSignals.at(i)->Draw("E0,same");
    }
  }*/

  //--------- Adjust max and min for the plot
  if (verbose) cout << "[Plot::DrawStack] Adjusting axis and histogram details." << endl;
  Double_t maxData = doData? hData->GetMax() : hAllBkg->GetMax();
  Double_t maxMC   = hAllBkg->GetMax();
  Double_t Max     = maxMC > maxData? maxMC : maxData;
  if (verbose) cout << "[Plot::DrawStack] maxMC   = " << maxMC   << endl;
  if (verbose) cout << "[Plot::DrawStack] maxData = " << maxData << endl;

  if (doSetLogy) {
    if (verbose) cout << "[Plot::DrawStack] Setting log scale in Y axis." << endl;
    if (PlotMinimum == 0 || PlotMinimum == -999)  PlotMinimum = 0.1;
    PlotMaximum = PlotMaximum == -999? Max*ScaleLog : PlotMaximum;
    hStack->SetMaximum(PlotMaximum);
    hStack->SetMinimum(PlotMinimum);
    plot->SetLogy();
  }
  else {
    PlotMinimum = PlotMinimum == -999? 0 : PlotMinimum;
    PlotMaximum = PlotMaximum == -999? Max*ScaleMax : PlotMaximum;

    hStack->SetMaximum(PlotMaximum);
    hStack->SetMinimum(PlotMinimum);
  }

  SetAxis(hStack->GetYaxis(), ytitle, ytitleSize, ytitleOffset, ytitleDivisions, ytitleLabelSize);
  if (centerYaxis) hStack->GetYaxis()->CenterTitle();
  hStack->GetXaxis()->SetLabelSize(0.0);

  //--------- Draw signal(s)
  if (verbose) cout << "[Plot::DrawStack] Drawing signal(s)." << endl;
  if (doSignal && (SignalStyle == "scan" || SignalStyle == "BSM" || SignalStyle == "")) {
    if (verbose) cout << "[Plot::DrawStack] Signal style: scan ----> nSignals = " << nSignals << endl;
    if (doNorm) {
      for (Int_t  i = 0; i < nSignals; i++) {
        TH1D* tmpSig = (TH1D*)VSignals.at(i)->Clone("tmpSig");
        tmpSig->Scale(1 / VSignals.at(i)->Integral());
        tmpSig->Draw(SignalDrawStyle + "same");
      }
    }
    else for (Int_t  i = 0; i < nSignals; i++) VSignals.at(i)->Draw(SignalDrawStyle + "same");
    if (verbose) cout << "[Plot::DrawStack] Signals drawn." << endl;
  }

  //---------  Draw systematic errors
  if (doSys) {
    if (verbose) cout << "[Plot::DrawStack] Drawing systematic uncertainties." << endl;
    hAllBkg->SetFillStyle(3444); // 3444 o 3004 (3145 default here)
    hAllBkg->SetFillColor(StackErrorColor); // kGray+2 as default
    hAllBkg->SetLineColor(StackErrorColor);
    hAllBkg->SetLineWidth(0);
    hAllBkg->SetMarkerSize(0);
  }

  if (doSys && ((Int_t) VSystLabel.size() > 0 || doExternalSyst)) hAllBkg->Draw("same,e2");

//   for(Int_t  i = 0; i < nSignals; i++)
//     VSignalsStack.at(i)->Draw("hist,same");

  //--------- Draw Data
  if (!Xerrorbars) {
    ex1 = new TExec("ex1", "gStyle->SetErrorX(0.);");
    ex2 = new TExec("ex2", "gStyle->SetErrorX(0.5);");
    ex1->Draw("same");
  }
  if (doData && RatioStyle != "S/B") {
    if (verbose) cout << "[Plot::DrawStack] Drawing data." << endl;
    hData->Draw(dataStyle);
  }

//   if(doSignal && (SignalStyle == "scan" || SignalStyle == "BSM" || SignalStyle == "") ){
//     for(Int_t  i = 0; i < nSignals; i++)
//       VSignalsStack.at(i)->Draw("hist,same");
//   }

  if (!Xerrorbars) ex2->Draw("same");

  //--------- Draw systematics ratio
  if (verbose) cout << "[Plot::DrawStack] Drawing systematics ratio." << endl;
  if (verbose) cout << "[Plot::DrawStack] WARNING: ratio normalisation not implemented for uncertainties." << endl;
  Int_t nbins = hAllBkg->GetNbinsX(); Double_t binval = 0; Double_t errbin = 0; Double_t totalerror = 0;
  TH1D* hratioerr =  (TH1D*) hAllBkg->Clone("hratioerr");
  if (doSys) {
    hAllBkg->SetFillStyle(StackErrorStyle);
    Int_t nbins = hAllBkg->GetNbinsX(); Double_t binval = 0; Double_t errbin = 0; Double_t totalerror = 0;
    cout << "[Plot::DrawStack] Going through the doSys.." << endl;
    for (Int_t bin = 1; bin <= nbins; bin++){  // Set bin error
      totalerror = hAllBkg->GetBinError(bin);
      binval = hAllBkg->GetBinContent(bin);
      errbin = binval > 0 ? totalerror/binval : 0.0;
      hratioerr->SetBinContent(bin, 1);
      hratioerr->SetBinError(bin, errbin);
    }
    hratioerr->SetFillColor(RatioErrorColor);
    hratioerr->SetFillStyle(RatioErrorStyle);
    hratioerr->SetMarkerSize(0);
  }

  //--------- Set legend and other texts
  if (verbose) cout << "[Plot::DrawStack] Setting legend and other texts." << endl;
  TLegend* leg = SetLegend();
  if (doLegend) leg->Draw("same");
  texcms->Draw("same");     // CMS
  texlumi->Draw("same");    // The luminosity
  texPrelim->Draw("same");  // Preliminary
  if (chlabel != "") {
    SetTexChan();
    texchan->Draw("same");
  }

  //---------- Set ratio... with Data, S/B, etc
  pratio->cd();
  TLine *hline = nullptr;
  if (RatioStyle == "S/B") {
    if (verbose) cout << "[Plot::DrawStack] Drawing Ratio: S/B!\n";
    if (!doSignal) cout << "[Plot::DrawStack] WARNING: cannot print ratio Signal/Background without signal!!" << endl;
    else {
      if (verbose) cout << "[Plot::DrawStack] Integral of hAllBkg: " << hAllBkg->Integral() << ", yield: " << hAllBkg->GetYield() << endl;
      if (verbose) cout << "[Plot::DrawStack] Integral of hSignal: " << hSignal->Integral() << ", yield: " << hSignal->GetYield() << endl;
      Double_t StoBmean = hSignal->GetYield()/hAllBkg->GetYield();
      if (verbose) cout << "[Plot::DrawStack] StoBmean = " << StoBmean << endl;
      hratio = (TH1D*)hSignal->Clone("hratio");
      Double_t xlow = hratio->GetBinLowEdge(1);
      Double_t xup  = hratio->GetBinLowEdge(nbins+1);
      hline = new TLine(xlow, StoBmean, xup, StoBmean); hline->SetLineColor(kOrange-2);
      if (verbose) cout << "[Plot::DrawStack] Dividing by hratio..." << endl;
      if (verbose) cout << "[Plot::DrawStack] xlow = " << xlow << ", xup = " << xup << ", StoBmean = " << StoBmean << endl;
      hratio->Divide(hAllBkg);
      //Double_t rmax = hratio->GetMaximum()*1.15;
      //Double_t rmin = hratio->GetMinimum()*0.85;
      //SetRatioMin(rmin);
      //SetRatioMax(rmax);
  /*    for(Int_t bin = 1; bin <= nbins; bin++){  // Set bin error
        totalerror = hAllBkg->GetBinError(bin);
        binval = hAllBkg->GetBinContent(bin);
        errbin = binval > 0 ? totalerror/binval : 0.0;
        Double_t signalVal = hSignal->GetBinContent(bin);
        errbin = errbin*(signalVal/binval);
        hratioerr->SetBinContent(bin, StoBmean);
        hratioerr->SetBinError(bin, errbin);
      }*/
    }
  }
  else if (RatioStyle == "S/sqrtB")   {cout << "Option not implemented yet!!!! Sorry!!!! [DO IT YOURSELF!]\n";}
  else if (RatioStyle == "S/sqrtSpB") {cout << "Option not implemented yet!!!! Sorry!!!! [DO IT YOURSELF!]\n";}
  else if (RatioStyle == "S/SpB")     {
    if (doData) hratio = (TH1D*)hData->Clone("hratio");
    else        hratio = (TH1D*)hAllBkg->Clone("hratio");
    // ratio by hand so systematic (background) errors don't get summed up to statistical ones (data)
    for (Int_t bin = 0; bin < hratio->GetNbinsX(); ++bin) {
      if (hratio->GetBinContent(bin+1) > 0) {
        hratio->SetBinContent( bin+1, hratio->GetBinContent(bin+1) / (hAllBkg->GetBinContent(bin+1) + hSignal->GetBinContent(bin+1)));
        hratio->SetBinError  ( bin+1, hratio->GetBinError  (bin+1) / (hAllBkg->GetBinContent(bin+1) + hSignal->GetBinContent(bin+1)));
      }
      else { hratio->SetBinError  ( bin+1, 0.); }
    }
  }
  else { // ratio Data/MC
      if (doData) hratio = (TH1D*)hData->Clone("hratio");
      else        hratio = (TH1D*)hAllBkg->Clone("hratio");
      // ratio by hand so systematic (background) errors don't get summed up to statistical ones (data)
      for (Int_t bin = 0; bin < hratio->GetNbinsX(); ++bin) {
        if (hratio->GetBinContent(bin+1) > 0){
          hratio->SetBinContent( bin+1, hratio->GetBinContent(bin+1) / hAllBkg->GetBinContent(bin+1));
          hratio->SetBinError  ( bin+1, hratio->GetBinError  (bin+1) / hAllBkg->GetBinContent(bin+1));
        }
        else { hratio->SetBinError  ( bin+1, 0.); }
      }
  }
  SetHRatio(hratio);
  //if(!RatioYtitle.Contains("S")) hratio->SetLineWidth(0);
  hratio->Draw("sameE1X0");

  if (verbose) cout << "[Plot::DrawStack] Drawing hline...\n" << endl;
  if (RatioStyle == "S/B") hline->Draw();
  if (doSys) {
    hratioerr->Draw("same,e2");
    hratio->Draw("same");
  }

//-------- Saving options
  TString dir = plotFolder;
  TString plotname = (outputName == "")? varname : outputName;
  if(outputName != "" && varname != "")  plotname += "_" + varname;
  if(outputName != "" && NoShowVarName)  plotname = outputName;
  if(outputName != "" && tag != "")      plotname += "_" + tag;
  else outputName = tag;

  gSystem->mkdir(dir, kTRUE);
  plotname.ReplaceAll(" ","");
  plotname.ReplaceAll("/","_");
  c->Print( dir + plotname + ".pdf", "pdf");
  c->Print( dir + plotname + ".png", "png");
  c->Print( dir + plotname + ".eps", "eps");
  c->SaveAs( dir + plotname + ".root");
  c->SaveAs( dir + plotname + ".C");
  delete c;
  if (!Xerrorbars) {
    delete ex1; delete ex2;
  }
  //if(leg) delete leg; if(hratioerr) delete hratioerr; if(hline) delete hline;
  //VStackedSignals.clear();
}



void Plot::ScaleProcess(TString pr, Double_t SF) {
  for(Int_t i = 0; i < (Int_t) VBkgs.size(); i++) if(VBkgs.at(i)->GetProcess() == (pr)) {
    VBkgs.at(i)->Scale(SF);
    VBkgs.at(i)->ReCalcValues();
  }
  for(Int_t i = 0; i < (Int_t) VSignals.size(); i++) if(VSignals.at(i)->GetProcess() == (pr)) {
    VSignals.at(i)->Scale(SF);
    VSignals.at(i)->ReCalcValues();
  }
  for(Int_t i = 0; i < (Int_t) VSyst.size(); i++) if(VSyst.at(i)->GetTag().BeginsWith(pr+"_")) {
    VSyst.at(i)->Scale(SF);
    VSyst.at(i)->ReCalcValues();
  }
}



void Plot::ScaleProcessBin(TString pr, Double_t SF, Int_t ibin){
  Double_t binContent;
  for(Int_t i = 0; i < (Int_t) VBkgs.size(); i++) if(VBkgs.at(i)->GetProcess() == (pr)){
    binContent = VBkgs.at(i)->GetBinContent(ibin);
    VBkgs.at(i)->SetBinContent(ibin, binContent*SF);
    VBkgs.at(i)->ReCalcValues();
  }
  for(Int_t i = 0; i < (Int_t) VSignals.size(); i++) if(VSignals.at(i)->GetProcess() == (pr)){
    binContent = VSignals.at(i)->GetBinContent(ibin);
    VSignals.at(i)->SetBinContent(ibin, binContent*SF);
    VSignals.at(i)->ReCalcValues();
  }
  for(Int_t i = 0; i < (Int_t) VSyst.size(); i++) if(VSyst.at(i)->GetTag().BeginsWith(pr+"_")){
    cout << "Scaling: " << VSyst.at(i)->GetTag() << endl;
    binContent = VSyst.at(i)->GetBinContent(ibin);
    VSyst.at(i)->SetBinContent(ibin, binContent*SF);
    VSyst.at(i)->ReCalcValues();
  }
}

void Plot::ScaleSignal(Double_t SF){
  ScaleProcess(SignalProcess, SF);
}

void Plot::ScaleSys(TString pr, TString sys, Double_t SF){
  GetHisto(pr, sys)->Scale(SF);
  GetHisto(pr,sys)->ReCalcValues();
}

//=======================================================================================
// Save all the histograms into a root file (also bin-to-bin statistical uncertainties)
//=======================================================================================
void Plot::SaveHistograms(){

  TString filename =  varname;
  if(outputName != "") {
    if(varname != "") filename = outputName + "_" + varname;
    else filename = outputName;
    if (NoShowVarName) filename = outputName;
  }
  gSystem->mkdir(limitFolder, kTRUE);
  f = new TFile(limitFolder + filename + ".root", "recreate");

  TH1D* statup; TH1D* statdown; Histo* nom;
  Int_t nVBkgs = (Int_t) VBkgs.size();
  Int_t nSig   = (Int_t) VSignals.size();
  Int_t nbins;
  for(Int_t i = 0; i < nVBkgs; i++){
    nom = VBkgs.at(i);
    nom->SetName(nom->GetProcess());
    nbins = nom->GetNbinsX();
    nom->Write();
    if(doStatUncInDatacard){
      if(nom->GetType() == itSys) continue; // no stat for systematics
      for(Int_t j = 1; j <= nbins; j++){
        statup   = nom->GetVarHistoStatBin(j, "up");
        statdown = nom->GetVarHistoStatBin(j, "down");
        statup  ->SetName(nom->GetProcess() + "_" + nom->GetProcess() + "_" + chan + Form("_statbin%i", j) + "Up");
        statdown->SetName(nom->GetProcess() + "_" + nom->GetProcess() + "_" + chan + Form("_statbin%i", j) + "Down");
        statup  ->Write(); statdown->Write();
      }
    }
  }
  TString namesignal;
  for(Int_t i = 0; i < nSig; i++){
    nom = VSignals.at(i);
    namesignal = nom->GetProcess();
    nom->SetName(namesignal);
    nbins = nom->GetNbinsX();
    nom->Write();
    if(doStatUncInDatacard){
      for(Int_t j = 1; j <= nbins; j++){
        statup   = nom->GetVarHistoStatBin(j, "up");
        statdown = nom->GetVarHistoStatBin(j, "down");
        statup  ->SetName(namesignal + "_" + namesignal + "_" + chan + Form("_statbin%i", j) + "Up");
        statdown->SetName(namesignal + "_" + namesignal + "_" + chan + Form("_statbin%i", j) + "Down");
        statup  ->Write(); statdown->Write();
      }
    }
  }
  for(Int_t i = 0; i < (Int_t) VSyst.size(); i++){
    nom = VSyst.at(i);
    nom->Write();
  }
  SetData(); GetStack();
  hData->SetName("data_obs");
  hData->SetTag("data_obs");
  hData->Write();
  hAllBkg->Write();
  hStack->Write();
  f->Close();
  cout << "All histograms saved in " << limitFolder + filename + ".root\n";
}

//================================================================================
// Other estetics and style
//================================================================================

void Plot::SetGoF(TString thegof)
{
  if(thegof=="" || thegof=="chi2" || thegof=="ks" || thegof=="ad")
    gof = thegof;
  else
    {
      cout << "Warning: unknown goodness of fit test. Defaulting to chi2" << endl;
      gof="chi2";
    }
}

void Plot::SetTexChan(){
  texchan = new TLatex(-20, 50, chlabel);
  texchan->SetNDC();
  texchan->SetTextAlign(12);
  texchan->SetX(chX);
  texchan->SetY(chY);
  texchan->SetTextFont(42);
  texchan->SetTextSize(texchansize);
  texchan->SetTextSizePixels(chSize);
}

void Plot::SetPad(TPad* pad, TString limits, TString margins, Bool_t doGrid) {
  vector<Float_t> vPadMargins = TStringToFloat(margins);
  vector<Float_t> vPadLimits  = TStringToFloat(limits);
  pad->SetPad(vPadLimits.at(0), vPadLimits.at(1), vPadLimits.at(2), vPadLimits.at(3));
  pad->SetTopMargin(vPadMargins.at(0)); pad->SetBottomMargin(vPadMargins.at(1)); pad->SetRightMargin(vPadMargins.at(2)); pad->SetLeftMargin(vPadMargins.at(3));
  if(doGrid) pad->SetGrid();
}

void Plot::SetHRatio(TH1D* h) {
  if (h == nullptr) h = hratio;
  h->SetTitle("");
  if      (RatioYtitle == "S/B"    )   h->GetYaxis()->SetTitle("S/B");
  else if (RatioYtitle == "S/sqrtB")   h->GetYaxis()->SetTitle("S/#sqrt{B}");
  else if (RatioYtitle == "S/sqrtSpB") h->GetYaxis()->SetTitle("S/#sqrt{S+B}");
  else                                 h->GetYaxis()->SetTitle(RatioYtitle);
/*
  h->GetXaxis()->SetTitleSize(0.05);
  h->GetXaxis()->SetTitleOffset(1.2);
  h->GetXaxis()->SetTitleSize(xAxisTitleSize);
  h->GetXaxis()->SetLabelOffset(0.02);
  h->GetXaxis()->SetLabelSize(xAxisLabelSize);

  h->GetYaxis()->SetTitleOffset(0.27);
  h->GetYaxis()->CenterTitle();
  h->GetYaxis()->SetTitleSize(0.13);
  h->GetYaxis()->SetLabelSize(0.13);
  h->GetYaxis()->SetNdivisions(402);
*/
  SetAxis(h->GetXaxis(), xtitle, xAxisTitleSize, xtitleOffset, xtitleDivisions, xAxisLabelSize);
  SetAxis(h->GetYaxis(), RatioYtitle , yRatioTitleSize, yRatioTitleOffset, 505, yRatioTitleLabelSize);
  h->GetYaxis()->CenterTitle();
  Int_t iBin = 1;
  for (auto& label : VBinLabels) {
    h->GetXaxis()->SetBinLabel( iBin, label );
    iBin++;
  }

  h->GetXaxis()->SetTitle(xtitle);
  h->SetMinimum(RatioMin);
  h->SetMaximum(RatioMax);
}

void Plot::SetAxis(TAxis *a, TString tit, Float_t titSize, Float_t titOffset, Int_t nDiv, Float_t labelSize){
  a->SetTitle(tit);
  a->SetTitleSize(titSize);
  a->SetTitleOffset(titOffset);
  a->SetNdivisions(nDiv);
  a->SetLabelSize(labelSize);
  a->SetNoExponent(kFALSE);
  TGaxis::SetMaxDigits(3);
}

void Plot::SetYaxis(TAxis *a){

  if (yAxisTitleStyle != ""){
    Double_t binWidth = hStack->GetXaxis()->GetBinWidth(1);
    ytitle = "Events";
    if ( yAxisTitleStyle.Contains("units,")){
      TString tmpStr = yAxisTitleStyle; tmpStr.ReplaceAll("units,","");
      ytitle +=  "/" + tmpStr + " units";
    }

    else if (yAxisTitleStyle == "gev"){
      ytitle += "/";
      ytitle +=  binWidth;
      ytitle += " GeV";
    }
  }


  a->SetTitle(ytitle);
  a->SetTitleSize(ytitleSize);
  a->SetTitleOffset(ytitleOffset);
  a->SetNdivisions(ytitleDivisions);
  a->SetLabelSize(ytitleLabelSize);
  a->SetNoExponent(kFALSE);
}

Int_t Plot::GetColorOfProcess(TString pr){
  for(Int_t i = 0; i < (Int_t) VBkgs.size(); i++) if(VBkgs.at(i)->GetProcess() == (pr)) return VBkgs.at(i)->GetFillColor();
  for(Int_t i = 0; i < (Int_t) VSignals.size(); i++) if(VSignals.at(i)->GetProcess() == (pr)) return VSignals.at(i)->GetLineColor();
  return 0;
}

void Plot::RemoveSystematic(TString sys){
  if(sys.Contains(",")){
    std::vector<TString> v = TStringToVector(sys);
    Int_t n = v.size();
    for(Int_t i = 0; i < n; i++) RemoveSystematic(v.at(i));
    return;
  }
  TString tag = "";
  for(Int_t k = 0; k < (Int_t) VSyst.size(); k++){
    if(VSyst.at(k)->GetTag() == sys || VSyst.at(k)->GetTag() == sys+"Up" || VSyst.at(k)->GetTag() == sys+"Down") VSyst.erase(VSyst.begin()+k);
  }
  for(Int_t j = 0; j < (Int_t) VSystLabel.size(); j++){
  tag = VSystLabel.at(j);
    if (sys.EndsWith("Up"))   sys = sys(0, sys.Sizeof()-3);
    if (sys.EndsWith("Down")) sys = sys(0, sys.Sizeof()-5);
    if(tag == sys || tag == sys + "Up" || tag == sys + "Down"){
      VSystLabel.erase(VSystLabel.begin()+j);
      if(verbose) cout << "Removing systematic " << tag << endl;
    }
  }
}

void Plot::UseEnvelope(TString pr, TString tags, TString newname){
  Histo* envelopeUp =  GetHisto(pr)->CloneHisto("envelopeUp"); Histo* envelopeDown = GetHisto(pr)->CloneHisto("envelopeDown");
  vector<Histo*> vhistos =  vector<Histo*>();
  vector<TString> v = TStringToVector(tags);
  if(verbose){
    for(Int_t i = 0; i < (Int_t) v.size(); i++) cout << v.at(i) << ", "; cout << endl;
  }
  // Naming the new systematic
  if(newname == "") newname = v.at(0);
  if(newname.EndsWith("Up")) newname = newname(0, newname.Sizeof()-3);
  else if(newname.EndsWith("Down")) newname = newname(0, newname.Sizeof()-5);
  if(verbose) cout << "New name of the systematic: " << newname << endl;
  for(Int_t k = 0; k < (Int_t) v.size(); k++) vhistos.push_back((Histo*) GetHisto(pr, v.at(k))->Clone(pr+"_"+v.at(k)+"cp"));

  envelopeUp   ->GetEnvelope(vhistos,  1);
  envelopeDown ->GetEnvelope(vhistos, -1);


  PrepareHisto(envelopeUp,   pr + "_Up", pr, itSys, 0, newname + "Up");
  PrepareHisto(envelopeDown, pr + "_Up", pr, itSys, 0, newname + "Down");
/*
  envelopeUp  ->SetProcess(pr); envelopeUp  ->SetTag(pr+"_"+newname+"Up");   envelopeUp  ->SetName(pr+"_"+newname+"Up");
  envelopeUp  ->SetType(itSys); envelopeUp->doStackOverflow = doStackOverflow; envelopeUp  ->SetStyle();
  envelopeDown->SetProcess(pr); envelopeDown->SetTag(pr+"_"+newname+"Down"); envelopeDown->SetName(pr+"_"+newname+"Down");
  envelopeDown->SetType(itSys); envelopeDown->doStackOverflow = doStackOverflow; envelopeDown->SetStyle();
  AddToHistos(envelopeUp);
  AddToHistos(envelopeDown);
*/
  AddToSystematicLabels(newname);

  RemoveSystematic(tags);
}

//================================================================================
// Printing tables, yields, systematics...
//================================================================================

Plot* Plot::NewPlot(TString newVar, TString newCut, TString newChan, Int_t newnbins, Double_t newbin0, Double_t newbinN, TString newtitle, TString newXtitle){
  if(newVar  == "") newVar  = var;
  if(newCut  == "") newCut  = cut;
  if(newChan == "") newChan = chan;
  if(newnbins == -1  ) newnbins = nb;
  if(newbin0  == -999) newbin0  = x0;
  if(newbinN  == -999) newbinN  = xN;
  if(newtitle == "" ) newtitle = title;
  if(newXtitle == "" ) newXtitle = xtitle;

  Plot* p = new Plot(newVar, newCut, newChan, newnbins, newbin0, newbinN, newtitle, newXtitle);
  p->SetPath(path); p->SetTreeName(treeName);
  p->SetOutputName(outputName);
  p->SetPathSignal(pathSignal);

  p->verbose         = false;
  p->doSys           = doSys;
  p->doData          = doData;
  p->doYieldsInLeg   = doYieldsInLeg;
  p->doSingleLep     = doSingleLep;
  p->doStackOverflow = doStackOverflow;
  p->doSignal        = doSignal;
  p->doSetLogy       = doSetLogy;
  p->doStatUncInDatacard = doStatUncInDatacard;

  p->SetSignalStyle(SignalStyle);
  p->SetSignalProcess(SignalProcess);

  Int_t nMCSamples   = VTagSamples.size();
  Int_t nDataSamples = VTagDataSamples.size();
  Int_t type;

  for(Int_t i = 0; i < nMCSamples; i++){
    type = i < (nMCSamples-nSignalSamples) ? itBkg : itSignal;
    p->AddSample(VTagSamples.at(i), VTagProcesses.at(i), type, GetColorOfProcess(VTagProcesses.at(i)));
  }
  for(Int_t i = 0; i < nDataSamples; i++)
    p->AddSample(VTagDataSamples.at(i), "Data", itData, 1);

  return p;
}


void Plot::PrintSamples() {
  std::cout << "All the samples included in the plot: " << std::endl;
  for(Int_t i = 0; i < (Int_t) VTagSamples.size(); i++)
    cout << " >>> Sample " << VTagSamples.at(i) << " in process " << VTagProcesses.at(i) << std::endl;
  for(Int_t i = 0; i < (Int_t) VTagDataSamples.size(); i++)
    cout << " >>> Data sample " << VTagDataSamples.at(i) << std::endl;
}


void Plot::PrintSystematics() {
  if (verbose) cout << "[Plot::PrintSystematics] Systematics included: \n";
  for (Int_t i = 0; i < (Int_t) VSystLabel.size(); i++)
    std::cout << " " << VSystLabel.at(i) << " ";
  std::cout << std::endl;
}


void Plot::PrintSystYields() {
  Int_t nBkgs = VBkgs.size();
  Int_t nSig  = VSignals.size();
  Int_t nSys  = VSystLabel.size();
  TString pr; TString sys;
  if (verbose) cout << "[Plot::PrintSystYields] Printing table..." << endl;
  cout << "\033[1;31m      ";
  for(Int_t gs = 0; gs < nSys; gs++) cout << "    " << VSystLabel.at(gs);
  cout << "\033[0m\n";
  for(Int_t i = 0; i < nBkgs+nSig; i++){
    if(i < nBkgs) pr = VBkgs.at(i)         ->GetProcess();
    else          pr = VSignals.at(i-nBkgs)->GetProcess();
    cout << Form("\033[1;33m  %s \033[0m ", pr.Data());
    cout << "\033[1;34m";
    for(Int_t j = 0; j < nSys; j++){
      sys = VSystLabel.at(j);
      cout << Form("   %1.2f ", TMath::Abs(GetYield(pr)-GetYield(pr,sys))/GetYield(pr)*100);
    }
    cout << "\033[0m\n";
  }
}


Double_t Plot::GetTotalSystematic(TString pr){
  Double_t sys2 = 0;
  Int_t nSys  = VSystLabel.size();
  Double_t nom = GetYield(pr);
  for(Int_t j = 0; j < nSys; j++){
    sys2 += fabs((GetYield(pr,VSystLabel.at(j))-nom) * (GetYield(pr,VSystLabel.at(j))-nom));
  }
  return TMath::Sqrt(sys2);
}


void Plot::PrintYields(TString cuts, TString labels, TString channels, TString options) {
  if (cuts == "") cuts = cut;
  //cuts.ReplaceAll(" ", "");
  std::vector<TString> VCuts = std::vector<TString>();
  std::vector<TString> VLCut = std::vector<TString>();
  std::vector<TString> VChan = std::vector<TString>();
  TString thisCut = ""; TString thisLabel = ""; TString thisChan;
  Int_t nBkgs = VBkgs.size();
  Int_t nSignals = VSignals.size();
  Int_t nrows = nBkgs + nSignals;
  if(nBkgs > 0) nrows++; if(doData) nrows++;
  Int_t ncolumns = 1 + cuts.CountChar(',');
  channels.ReplaceAll(" ", "");
  Bool_t doChannels = false; if(cuts.CountChar(',') == channels.CountChar(',')) doChannels = true;

  TResultsTable t(nrows, ncolumns, 1); //cout << Form("Creating table with [rows, columns] = [%i, %i]\n", nrows, ncolumns);
  t.SetRowTitleHeader("Process");
  t.SetFormatNum(tableFormats);
  Plot* np = NULL;
  for(Int_t k = 0; k < ncolumns; k++){
    if(cuts.Contains(",")){
      thisCut = cuts(0, cuts.First(','));
      thisLabel = labels(0, labels.First(','));
      thisChan = channels(0, channels.First(','));
      VCuts.push_back(thisCut);
      VLCut.push_back(thisLabel);
      if(doChannels) VChan.push_back(thisChan);
      else VChan.push_back(chan);
      cuts = cuts(cuts.First(',')+1, cuts.Sizeof());
      labels = labels(labels.First(',')+1, labels.Sizeof());
      channels = channels(channels.First(',')+1, channels.Sizeof());
    }
    else{
      VCuts.push_back(cuts);
      VLCut.push_back(labels);
      if(doChannels) VChan.push_back(channels);
      else VChan.push_back(chan);
    }
  }

  // Set row titles
  for(Int_t i = 0; i < nBkgs; i++) t.SetRowTitle(i, VBkgs.at(i)->GetProcess());
  t.SetRowTitle(nBkgs, "Total Background");
  for(Int_t i = nBkgs+1; i < nSignals+nBkgs+1; i++) t.SetRowTitle(i, VSignals.at(i-(nBkgs+1))->GetProcess());
  if(doData) t.SetRowTitle(nBkgs+1+nSignals, "Data");

  // Set column titles
  for(Int_t k = 0; k < ncolumns; k++) t.SetColumnTitle(k, VLCut.at(k));

  // Fill the table with the yields
  for(Int_t k = 0; k < ncolumns; k++){
    if(VCuts.at(k) == cut) np = this;
    else{
      np = NewPlot(var, VCuts.at(k), VChan.at(k));
      for(Int_t i = 0; i < (Int_t) VSystLabel.size(); i++) np->AddSystematic(VSystLabel.at(i));
    }

    Double_t TotalBkgSystematic = 0;
    for(Int_t i = 0; i < nBkgs; i++){
      t[i][k] = np->VBkgs.at(i)->GetYield();
      t[i][k].SetError(np->GetTotalSystematic(np->VBkgs.at(i)->GetProcess()));
//      t[i][k].SetStatError(np->GetTotalSystematic(np->VBkgs.at(i)->GetProcess()));
      TotalBkgSystematic += (np->GetTotalSystematic(np->VBkgs.at(i)->GetProcess()))*(np->GetTotalSystematic(np->VBkgs.at(i)->GetProcess()));
    }
    TotalBkgSystematic = TMath::Sqrt(TotalBkgSystematic);
    np->GetStack();
    t[nBkgs][k] = np->hAllBkg->GetYield();
    t[nBkgs][k].SetError(TotalBkgSystematic);
//    t[nBkgs][k].SetStatError(TotalBkgSystematic);
    for(Int_t i = nBkgs+1; i < nSignals+nBkgs+1; i++){
      t[i][k] = np->VSignals.at(i-(nBkgs+1))->GetYield();
      t[i][k].SetError(np->GetTotalSystematic(np->VSignals.at(i-(nBkgs+1))->GetProcess()));
//      t[i][k].SetStatError(np->GetTotalSystematic(np->VSignals.at(i-(nBkgs+1))->GetProcess()));
    }
    if(doData){
      np->SetData();
      t[nBkgs+1+nSignals][k] = np->hData->GetYield();
      t[nBkgs+1+nSignals][k].SetError(TMath::Sqrt(np->hData->GetYield()));
//      t[nBkgs+1+nSignals][k].SetStatError(TMath::Sqrt(np->hData->GetYield()));
    }
  }
  if (verbose) cout << "[Plot::PrintYields] Printing table..." << endl;
  t.SetDrawHLines(true); t.SetDrawVLines(true); t.Print();
  gSystem->mkdir(plotFolder, kTRUE);
  if (options.Contains("tex"))  t.SaveAs(gSystem->ExpandPathName(plotFolder + "/" + YieldsTableName + ".tex"));
  if (options.Contains("html")) t.SaveAs(gSystem->ExpandPathName(plotFolder + "/" + YieldsTableName + ".html"));
  if (options.Contains("txt"))  t.SaveAs(gSystem->ExpandPathName(plotFolder + "/" + YieldsTableName + ".txt"));
}


void Plot::PrintBinsYields(TString options){
  Int_t nBkgs = VBkgs.size();
  Int_t nSignals = VSignals.size();
  Int_t nrows = nBkgs + nSignals;
  if(nBkgs > 0) nrows++;
  if(doData) nrows++;
  Int_t ncolumns = nb;

  TResultsTable t(nrows, ncolumns, 1); //cout << Form("Creating table with [rows, columns] = [%i, %i]\n", nrows, ncolumns);
  t.SetRowTitleHeader("Process");
  t.SetFormatNum(tableFormats);

  // Set row titles
  for(Int_t i = 0; i < nBkgs; i++) t.SetRowTitle(i, VBkgs.at(i)->GetProcess());
  t.SetRowTitle(nBkgs, "Total bkg");
  for(Int_t i = nBkgs+1; i < nSignals+nBkgs+1; i++) t.SetRowTitle(i, VSignals.at(i-(nBkgs+1))->GetProcess());
  if(doData) t.SetRowTitle(nBkgs+nSignals+1, "Data");

  // Set column titles
  Double_t l0; Double_t l1;
  for(Int_t k = 0; k < ncolumns; k++){
    if(x0 == xN){
      l0 = vbins[k];
      l1 = vbins[k+1];
    }
    else{
      l0 = x0 + k*(xN - x0)/nb;
      l1 = x0 + (k+1)*(xN - x0)/nb;
    }
    t.SetColumnTitle(k, Form("[%2.0f, %2.0f]", l0, l1));
  }

  // Fill the table with the yields
  TString pr; Double_t nom; Double_t var;
  Double_t bTotBkgSyst= 0; Double_t bTotBkg    = 0;
  for(Int_t k = 0; k < ncolumns; k++){
    //>>> Yields for bkg
    bTotBkgSyst= 0; bTotBkg = 0;
    for(Int_t i = 0; i < nBkgs; i++){
      pr = VBkgs.at(i)->GetProcess();
      nom = GetBinYield(pr, k+1); var = GetBinYield(pr, k+1, "Up");
      t[i][k] = nom;
      t[i][k].SetError( TMath::Abs(nom-var));
      bTotBkg     += nom;
      bTotBkgSyst += (nom-var)*(nom-var);
    }

    //>>> Total bkg
    bTotBkgSyst= TMath::Sqrt(bTotBkgSyst);
    t[nBkgs][k] = bTotBkg;
    t[nBkgs][k].SetError(bTotBkgSyst);

    //>>> Yields for signal
    for(Int_t i = nBkgs+1; i < nSignals+nBkgs+1; i++){
      pr = VSignals.at(i-(nBkgs+1))->GetProcess();
      nom = GetBinYield(pr, k+1); var = GetBinYield(pr, k+1, "Up");
      t[i][k] = nom;
      t[i][k].SetError( TMath::Abs(nom-var));
    }
    if(doData){
      pr = "Data";
      nom = GetBinYield(pr, k+1); var = GetBinYield(pr, k+1, "Up");
      t[nBkgs+nSignals+1][k] = nom;
      t[nBkgs+nSignals+1][k].SetError( TMath::Abs(nom-var));
    }
  }
  t.SetDrawHLines(true); t.SetDrawVLines(true); t.Print();
  gSystem->mkdir(plotFolder, kTRUE);
  if(options.Contains("tex"))  t.SaveAs(gSystem->ExpandPathName(plotFolder + "/" + YieldsTableName + ".tex"));
  if(options.Contains("html")) t.SaveAs(gSystem->ExpandPathName(plotFolder + "/" + YieldsTableName + ".html"));
  if(options.Contains("txt"))  t.SaveAs(gSystem->ExpandPathName(plotFolder + "/" + YieldsTableName + ".txt"));
}


void Plot::AddNormUnc(TString pr, Double_t systUp, Double_t systDown){
  if(systDown == -99) systDown = systUp;
  Histo* hUp   = GetHisto(pr)->CloneHisto(pr + "_" + pr + "Up");
  Histo* hDown = GetHisto(pr)->CloneHisto(pr + "_" + pr + "Down");
  hUp->SetType(itSys); hDown->SetType(itSys);
  hUp->SetTag(pr + "_" + pr + "Up"); hDown->SetTag(pr + "_" + pr + "Down");
  hUp->SetSysTag(pr+"Up"); hDown->SetSysTag(pr+"Down");
  hUp->Scale(1+systUp); hDown->Scale(1-systDown);
  hUp->SetDirectory(0); hDown->SetDirectory(0);
  AddToSystematicLabels(pr);
  AddToHistos(hUp); AddToHistos(hDown);
  return;
}

Double_t Plot::GetBinYield(TString pr, Int_t bin, TString systag){
  if     (systag == "Up"   || systag == "UP"   || systag == "up"  ) systag = "Up";
  else if(systag == "Down" || systag == "DOWN" || systag == "down") systag = "Down";
  if(pr == "Data"){
    if(!hData) SetData();
    if(systag == "" || systag == "0") return hData->GetBinContent(bin);
    else{
      if(systag.Contains("Down") || systag.Contains("down")) return hData->GetBinContent(bin) - hData->GetBinError(bin);
      else return hData->GetBinContent(bin) + hData->GetBinError(bin);
    }
  }
  Double_t val = 0; Double_t sys = 0; TString ps;
  Int_t nSyst = VSyst.size();
  Int_t nBkg = VBkgs.size();
  Int_t nSig = VSignals.size();
  Double_t var = 0;
  if(systag == "Up" || systag == "Down"){
    Double_t nom = GetBinYield(pr, bin, "0");
    var = 0; Double_t diff = 0; Double_t tempvar = 0;
    for(Int_t k = 0; k < nSyst; k++){ // Systematics in k
      ps = VSyst.at(k)->GetTag();
      if(!ps.BeginsWith(pr+"_"))   continue;
      if(!ps.Contains(systag)) continue;
      tempvar = VSyst.at(k)->GetBinContent(bin);
      //cout << ">>> pr = " << ps << endl;
      //cout << ">>> nom = " << nom << ", var = " << tempvar << endl;
      diff += (tempvar-nom)*(tempvar-nom);
    }
    var = TMath::Sqrt(diff);
    if     (var != 0 && systag == "Up")   return nom + var;
    else if(var != 0 && systag == "Down") return nom - var;
  }
  else if(systag == "" || systag == "0"){
    for(Int_t i = 0; i < nBkg; i++){
      if(pr == VBkgs.at(i)->GetProcess()) return  VBkgs.at(i)->GetBinContent(bin);
    }
    for(Int_t i = 0; i < nSig; i++){
      if(pr == VSignals.at(i)->GetProcess()) return  VSignals.at(i)->GetBinContent(bin);
    }
    return 0;
  }
  else{
    var = 0;
    for(Int_t k = 0; k < nSyst; k++){ // Systematics in k
      ps = VSyst.at(k)->GetTag();
      if(!ps.BeginsWith(pr))   continue;
      if(!ps.Contains(systag)) continue;
      var = VSyst.at(k)->GetBinContent(bin);
      if(var != 0) return var;
    }
  }
  //cout << "[Plot::GetYield] WARNING: No systematic " << systag << " for process " << pr << "!!! ...... Returning nominal value... " << endl;
  return GetBinYield(pr, bin);
}

void Plot::Reset(){
  VData.clear();
  VBkgs.clear();
  VSignals.clear();
  VSignalsErr.clear();
  VSyst.clear();
  VSumHistoSystUp.clear();
  VSumHistoSystDown.clear();
  VSystLabel.clear();
  VTagDataSamples.clear();
  if(hratio) delete hratio;
  if(TotalSysUp) delete TotalSysUp;
  if(TotalSysDown) delete TotalSysDown;
//  if(hData && doData) delete hData;
//  if(hStack) delete hStack;
//  if(hAllBkg) delete hAllBkg;
  VBinLabels.clear();
  RatioMin = 0.8;
  RatioMax = 1.2;
  ScaleMax = 1.2;
  ScaleLog = 500;
  PlotMinimum = -999;
  PlotMaximum = -999;
}


void Plot::AddPlotFromHyperlooper(Hyperlooper *HyperLoop, TString plotname){
  distribution d = HyperLoop->GetDistribution(plotname);
  var  = d.var; cut  = d.cut; chan = d.chan;
  nb   = d.nbins; x0   = d.bin0;  xN   = d.binN; vbins = d.bins;
  LoopOptions = d.options;
  weight = HyperLoop->GetWeight();
  systematics = HyperLoop->GetSyst();
  if(systematics != "0" && systematics != "")
    AddToSystematicLabels(systematics);

  Int_t type = HyperLoop->GetType(); Int_t color = HyperLoop->GetColor();
  TString process = HyperLoop->GetProcess();
  Int_t nHistos = d.vh.size();
  TString sampleName = HyperLoop->GetSampleName();
  TString systag;

  for(Int_t i = 0; i < nHistos; i++){
    systag = d.vh.at(i)->GetSysTag();
    if(systag != "0" && systag != "") type = itSys;
    if(type != itData && !((HyperLoop->GetSampleOptions()).Contains("noScaleLumi")) ) d.vh.at(i)->Scale(Lumi*1000);
    PrepareHisto(d.vh.at(i), sampleName, process, type, color);
  }
}

/*
//=========================================== MULTIPLOT

void MultiPlot::AddHyperlooper(TString sample, TString process, Int_t type, Int_t color, TString syst, TString weight, TString options, TString pathS){
  nDist = Dname.size();
  TString pathToMiniTree;
  pathToMiniTree = pathS == ""? path : pathS;
  //if     (type == itSignal || sample.Contains("T2tt")) pathToMiniTree = pathSignal;
  //else if(type == itData  ) pathToMiniTree = pathData;
  if(sample.Contains("/")){
    pathToMiniTree = sample(0, sample.Last('/')+1);
    sample = sample(sample.Last('/')+1, sample.Sizeof());
  }
  Hyperlooper* h = new Hyperlooper(pathToMiniTree, treeName, sample, process, type, color, weight, syst, options);
  for(Int_t i = 0; i < nDist; i++)
    h->AddDistribution(Dname.at(i), Dvar.at(i), Dcut.at(i), Dchan.at(i), Dnbins.at(i), Dbin0.at(i), DbinN.at(i), Dbins.at(i));
  h->Fill();
  HL.push_back(h);
}

void MultiPlot::Loop(){
  if((Int_t) HL.size() > 0) return;
  nSamples = VTagSamples.size();
  Int_t type; Int_t color;
  TString stype = "backgroud";

  for(Int_t i = 0; i < nSamples; i++){
    if     (VTypes.at(i) == itSignal) stype = "signal";
    else if(VTypes.at(i) == itData)   stype = "data";
    else if(VTypes.at(i) == itSys)    stype = "systematic";
    cout << Form("\033[1;39mAnalyzing sample: \033[1;31m%s \033[1;39m(\033[1;35m%s\033[1;39m) as \033[1;34m%s\033[0m\n", VTagSamples.at(i).Data(), VTagProcesses.at(i).Data(), stype.Data());
    AddHyperlooper(VTagSamples.at(i), VTagProcesses.at(i), VTypes.at(i), VColors.at(i), VSystL.at(i), VWeight.at(i), VOptions.at(i), VPaths.at(i));
  }
}



void MultiPlot::AddDistribution(TString name, TString var, TString cut, TString chan, Int_t nbins, Double_t bin0, Double_t binN, Double_t *bins){
  Dname.push_back(name);
  Dvar.push_back(var);
  Dcut.push_back(cut);
  Dchan.push_back(chan);
  //Dweight.push_back(weight);
  //DSyst.push_back(sys);
  Dnbins.push_back(nbins);
  Dbin0.push_back(bin0);
  DbinN.push_back(binN);
  Dbins.push_back(bins);
}

void MultiPlot::AddSample(TString p, TString pr, Int_t type, Int_t color, TString syst, TString weight, TString options){
  p.ReplaceAll(" ", "");
  if(pr == "") pr = p;
  if(p.Contains(",")){
    TString First_p = p(0, p.First(','));
    TString theRest = p(p.First(',')+1, p.Sizeof());
    AddSample(First_p, pr, type, color, syst, weight, options);
    AddSample(theRest, pr, type, color, syst, weight, options);
    return;
  }
  TString pathSample = path;
  if(type == itData) pathSample  = pathData;
  if(type == itSignal) pathSample  = pathSignal;
  VTagSamples.push_back(p);
  VTagProcesses.push_back(pr);
  VTypes.push_back(type);
  VColors.push_back(color);
  VSystL.push_back(syst);
  VWeight.push_back(weight);
  VOptions.push_back(options);
  VPaths.push_back(pathSample);
}


void MultiPlot::SetPlot(TString name, TString xtitle, TString ytitle, TString seltext, Double_t ratioMax, Double_t ratioMin){
  Reset();
  Loop();
  nSamples = VTagSamples.size();
  for(Int_t i = 0; i < nSamples; i++)
    AddPlotFromHyperlooper(HL.at(i), name);
  SetTitleX(xtitle);
  SetTitleY(ytitle);
  SetChLabel(seltext);
  SetRatioMax(ratioMax);
  if(ratioMin == -999) ratioMin = 2-ratioMax;
  SetRatioMin(ratioMin);
}




    // Draw systematics signal

  Histo* hSignalerr = NULL;
  VSignalsErr.clear();
  if(verbose) cout << "Drawing " << nSignals << " signals..." << endl;
      for(Int_t  i = 0; i < nSignals; i++){
      if(VSignals.at(i)->GetType() != itSignal) continue; // Consistency
      hSignalerr = (Histo*) VSignals.at(i)->Clone("hSignalErr"); // Add systematics to signal
      hSignalerr->SetFillColor(17); hSignalerr->SetMarkerStyle(0);
      hSignalerr->SetFillStyle(3013); VSignalsErr.push_back(hSignalerr);
      }
      //if(doSys) VSignalsErr.at(i)Stat->Draw("same,e2");*/
